# Начало Работы

В центре любого Vuex-приложения находится **хранилище**. "Хранилище" — это, упрощённо говоря, контейнер, который хранит **состояние** вашего приложения. Два момента отличают хранилище Vuex от простого глобального объекта:

1. Хранилища Vuex реактивны. Если компоненты Vue зависят от их состояния, изменения состояния хранилища спровоцирует соответствующие изменения компонентов.

2. Непосредственное изменение состояния хранилища запрещено. Единственная возможность для внесения изменений — явный **вызов мутаций**. Этот подход позволяет быть уверенным, что каждое изменение оставляет в системе след, и даёт возможность использовать инструменты, позволяющие лучше понять работу приложения.

### Простейшее Хранилище

> **ЗАМЕЧАНИЕ:** Мы будем использовать синтаксис ES2015 для примеров кода на всём протяжении этой документации. Если вы с ним ещё не разобрались, [сейчас самое время](https://babeljs.io/docs/learn-es2015/)!

После [установки](installation.md) Vuex, давайте создадим хранилище. Всё довольно просто: нужно лишь указать исходное состояние и мутации:

``` js
// Удостоверьтесь, что вызвали Vue.use(Vuex) в коде ранее, если используете модульный сборщик

const store = new Vuex.Store({
  state: {
    count: 0
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})
```

Теперь мы можем получить доступ к объекту состояния посредством `store.state`, или вызвать изменение состояния методом `store.commit`:

``` js
store.commit('increment')

console.log(store.state.count) // -> 1
```

Ещё раз заметим, что причина, по которой мы вызываем мутацию вместо того чтобы напрямую изменить `store.state.count`, заключается в том, что мы хотим явным образом отслеживать изменения. Простое архитектурное соглашение делает наши намерения более очевидными, позволяя упростить размышления об изменениях состояния приложения при чтении кода. Кроме того, этот подход позволяет реализовать инструменты, способные логировать каждую мутацию, делать моментальные слепки состояния приложения, и даже использовать "машину времени" при отладке.

Использование состояния хранилища в компонентах, из-за реактивной природы хранилища, требует исключительно создания вычисляемых свойств. Изменения состояния можно вызывать, инициализируя мутации в методах компонентов.

Вот пример [простейшего приложения Vuex, реализующего счётчик](https://jsfiddle.net/yyx990803/n9jmu5v7/).

Далее мы более подробно обсудим каждую из основных концепций, начиная с [Состояния](state.md)
