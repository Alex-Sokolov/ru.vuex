# Мутации

Единственным способом изменения состояния хранилища во Vuex является использование мутаций. Мутации во Vuex очень похожи на события: каждая мутация имеет строковый **тип** и **функцию-обработчик**. В этом обработчике и происходят собственно изменения состояния, которое передаётся в функцию на позиции первого аргумента:

``` js
const store = new Vuex.Store({
  state: {
    count: 1
  },
  mutations: {
    increment (state) {
      // изменяем состояние
      state.count++
    }
  }
})
```

Вызывать функцию-обработчик напрямую — нельзя. Ситуация больше похожа на обработку события: "Когда мутация типа `increment` инициирована, вызывается этот обработчик". Чтобы инициировать обработку мутации, необходимо вызвать **store.commit**, указав её тип:

``` js
store.commit('increment')
```

### Мутации с Нагрузкой

При вызове `store.commit`, мутации можно также передать дополнительный параметр, называемый **нагрузкой**:

``` js
// ...
mutations: {
  increment (state, n) {
    state.count += n
  }
}
```
``` js
store.commit('increment', 10)
```

В большинстве случаев нагрузка будет объектом, содержащим несколько полей. Запись мутаций в таком случае становится более описательной:

``` js
// ...
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
```
``` js
store.commit('increment', {
  amount: 10
})
```

### Объектный Синтаксис

Альтернативным способом вызова мутации является использование единственного параметра, в котором `type` указывается напрямую:

``` js
store.commit({
  type: 'increment',
  amount: 10
})
```

При использовании объектной записи, объект передаётся в качестве нагрузки целиком, так что обработчик остаётся тем же самым:

``` js
mutations: {
  increment (state, payload) {
    state.count += payload.amount
  }
}
```

### Молчаливые Мутации

> Замечание: Эта возможность вероятно будет помечена как нерекоммендованная к использованию после появления функционала фильтрации в devtools.

По умолчанию, каждая инициируемая мутация попадает в плагины (например, в инструменты разработчика). Иногда, впрочем, не хочется, чтобы плагины записывали каждое изменение состояния. Множественные мутации, происходящие в течении короткого периода времени не всегда необходимо отслеживать. В таких случаях существует возможность передать в `store.commit` третий параметр чтобы "заставить замолчать" эту конкретную мутацию и сделать её невидимой в плагинах:

``` js
store.commit('increment', {
  amount: 1
}, { silent: true })

// при использовании объектного синтаксиса
store.commit({
  type: 'increment',
  amount: 1
}, { silent: true })
```

### Мутации Следуют Правилам Реактивности Vue

Поскольку состояние хранилища Vuex — это реактивная переменная Vue, при возникновении мутации зависящие от этого состояния компоненты Vue обновляются автоматически. Кроме того, это значит, что мутации Vuex имеют те же самые скользкие места, что и реактивность в обычном Vue:

1. Предпочтительна инициализация изначального состояния хранилища с указанием всех полей в самом начале.

2. При добавлении новых свойств объекту необходимо либо:

  - Использовать `Vue.set(obj, 'newProp', 123)`, либо же - 

  - Целиком заменить старый объект новым. Например, используя [синтаксис распространения объектов](https://github.com/sebmarkbage/ecmascript-rest-spread) из stage-3, можно написать так:

    ``` js
    state.obj = { ...state.obj, newProp: 123 }
    ```

### Использование Констант для обозначения Типов Мутаций

В различных вариантах имплементации Flux этот подход используется весьма часто. Вынесение всех констанс типов мутаций и действий в отдельный файл позволяет не только лучше использовать такие инструменты, как линтеры, но и одним взглядом узнать, какие мутации возможны в приложении:

``` js
// mutation-types.js
export const SOME_MUTATION = 'SOME_MUTATION'
```

``` js
// store.js
import Vuex from 'vuex'
import { SOME_MUTATION } from './mutation-types'

const store = new Vuex.Store({
  state: { ... },
  mutations: {
    // вычисляемые имена из ES2015 позволяют использовать
    // константу в качестве имени функции
    [SOME_MUTATION] (state) {
      // mutate state
    }
  }
})
```

Тем не менее, использование констант для указания типов мутаций полностью опционально, хотя и может оказаться полезным в крупных проектах.

### Мутации Должны Быть Синхронными

Нужно помнить одно важное правило: **обработчики мутаций обязаны быть синхронными**. Почему? Рассмотрим пример:

``` js
mutations: {
  someMutation (state) {
    api.callAsyncMethod(() => {
      state.count++
    })
  }
}
```

Теперь представьте, что отлаживаете приложение и смотрите в лог мутаций в интрументарии разработчика. Для каждой залогированной мутации, devtools должен сохранить слепки состояния приложения "до" и "после". Однако, асинхронный коллбэк внутри приведённой выше мутации делает это невозможным: мутация-то уже записана, и у devtools нет никакой возможности знать, что будет вызван коллбэк, а значит инициируемые им изменения становится, по сути, невозможно отследить.

### Вызов Мутаций из Компонентов

Мутации можно вызывать из кода компонентов, используя `this.$store.commit('xxx')`, или применяя хелпер `mapMutations`, который проксирует вызовы `store.commit` через методы компонента (для этого требуется наличие корневой ссылки на хранилище через `$store`):

``` js
import { mapMutations } from 'vuex'

export default {
  // ...
  methods: {
    ...mapMutations([
      'increment' // this.increment() будет вызывать this.$store.commit('increment')
    ]),
    ...mapMutations({
      add: 'increment' // this.add() будет вызывать this.$store.commit('increment')
    })
  }
}
```

### О Действиях

Привнесение асинхронности в мутации может изрядно затруднить понимание логики программы. Например, если вызываются два метода, оба с асинхронными коллбэками, изменяющими состояние приложения, откуда нам знать, какой из коллбэков будет вызван первым? Именно поэтому мы разделяем концепции изменений и асинхронности. Во Vuex, **мутации — это синхронные транзакции**:

``` js
store.commit('increment')
// все изменения состояния, вызываемые мутацией "increment",
// к этому моменту уже должны произойти.
```

Для обработки асинхронных операций существуют [Действия](actions.md).
